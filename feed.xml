<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>SDP日常笔记</title><link>http://sdphome.github.io/</link><description></description><lastBuildDate>Mon, 23 Jun 2014 18:26:01 +0800</lastBuildDate><item><title>sudoers文件属性为777后无法使用root</title><link>http://sdphome.github.io/ubuntu/sudoers-777-unable-root.html</link><description>&lt;h2 id="d6cfc9817231ad285f5e51b0d89b9e6e"&gt;问题形成原因&lt;/h2&gt;
&lt;p&gt;在使用ubuntu时有时为了添加root权限，需要将用户信息添加进&lt;code&gt;/etc/sudoers&lt;/code&gt;，有些人为了方便，将这个文件的权限修改为777了，接着发现sudo的时候想使用root权限不可以了..&lt;/p&gt;
&lt;h2 id="957a228f87aaf86e436762129485625a"&gt;解决方法&lt;/h2&gt;
&lt;p&gt;重启机器，在开机的过程中长按&lt;code&gt;shift&lt;/code&gt;键，使ubuntu进入grub mode，进入root shell，在root shell中输入下面两条命令即可:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mount -o rw,remount /
chmod 440 /etc/sudoers
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Shao Depeng</dc:creator><pubDate>Mon, 23 Jun 2014 18:26:01 +0800</pubDate><guid isPermaLink="false">tag:sdphome.github.io,2014-06-23:ubuntu/sudoers-777-unable-root.html</guid><category>root</category><category>ubuntu</category><category>sudoers</category></item><item><title>Android HAL层实现与调用</title><link>http://sdphome.github.io/android/android_hal_call_and_achieve.html</link><description>&lt;h2 id="42cd81a3f07e1360c430197f8e4e46ae"&gt;HAL层实现&lt;/h2&gt;
&lt;p&gt;在这篇文章中我们讨论下HAL层代码的简单组成，以及jni是如何调用HAL层代码。文章尽量避免了一些无用信息，直接写有实际的东西。&lt;/p&gt;
&lt;p&gt;在这里我用一个简单的HAL层代码(电子防眩目的hal代码)来开始我们的讲解。&lt;/p&gt;
&lt;p&gt;在一个hal代码中主要的工作是实现一个名为&lt;code&gt;HAL_MODULE_INFO_SYM&lt;/code&gt;的module实例，其结构定义为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    struct lcd_reflect_module_t {
        struct hw_module_t common;
    };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这个结构的名字是随意的，一般用(模块名_module_t)来表示，可以看到它只有一个成员变量hw_module_t，也就是说主要的工作就是填充这个hw_module_t这个结构了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;const struct lcd_reflect_module_t HAL_MODULE_INFO_SYM = {
    .common = {
        .tag = HARDWARE_MODULE_TAG,
        .version_major = 1,
        .version_minor = 0,
        .id = LCD_REFLECT_HARDWARE_MODULE_ID,
        .name = "LCD Reflect",
        .author = "Archermind Tech.",
        .methods = &amp;amp;lcd_reflect_module_methods,
    }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其中只有一个open函数指针，作为module的callback。&lt;/p&gt;
&lt;p&gt;前面我们已经接触了两个重要的结构体，hw_module_t和hw_module_methods_t，下面我们还需要来看一下hal层中第三个重要的结构体hw_device_t。&lt;/p&gt;
&lt;p&gt;下面我们来看一下&lt;code&gt;hw_module_methods_t&lt;/code&gt;中的open函数&lt;code&gt;lcd_reflect_module_methods&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;static int
lcd_reflect_open(const struct hw_module_t *module,

              const char *name, struct hw_device_t **device)
{
    int status = -EINVAL;

    LOGV("lcd_reflect_open\n");
    if (!strcmp(name, LCD_REFLECT_HARDWARE)) {
        struct lcd_reflect_device_t *dev;

        dev = malloc(sizeof (*dev));
        memset(dev, 0, sizeof (*dev));

        dev-&amp;gt;common.tag = HARDWARE_DEVICE_TAG;
        dev-&amp;gt;common.version = 0;
        dev-&amp;gt;common.module = (struct hw_module_t *)module;
        dev-&amp;gt;common.close = lcd_reflect_close;

        *device = &amp;amp;dev-&amp;gt;common;

        dev-&amp;gt;get_level = &amp;amp;lcd_reflect_get_level;
        dev-&amp;gt;set_level = &amp;amp;lcd_reflect_set_level;
        dev-&amp;gt;get_state = &amp;amp;lcd_reflect_get_state;
        dev-&amp;gt;set_state = &amp;amp;lcd_reflect_set_state;

        status = 0;
    }

    return status;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到hw_device_t作为open的形参传入open函数中，并且我们还发现了另外一个结构体&lt;code&gt;struct lcd_reflect_device_t *dev;&lt;/code&gt;这个结构是我们模块自己定义的，用于存放一些我们模块需要的操作，jni层中就是通过这个结构体来调用hal层中提供的接口的。看一下它的定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct lcd_reflect_device_t {
    struct hw_device_t common;

    /**
     * Get the mxc_reflect state
     *
     * Returns: 0 on success, error code on failure
     */
    int (*get_state)(struct lcd_reflect_device_t *dev,
                     int *stat);

    /**
     * Set the mxc_reflect state
     *
     * Returns: 0 on success, error code on failure
     */
    int (*set_state)(struct lcd_reflect_device_t *dev,
                     int stat);

    /**
     * Get the mxc_reflect level
     *
     * Returns: 0 on success, error code on failure
     */
    int (*get_level)(struct lcd_reflect_device_t *dev,
                    int *level);

    /**
     * Set the mxc_reflect state
     *
     * Returns: 0 on success, error code on failure
     */
    int (*set_level)(struct lcd_reflect_device_t *dev,
                    int level);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面有hw_device_t这个成员，并且它是在最前面的一个成员，这个是非常重要的，我们将在下面说明为什么它需要放在最前面，除了hw_device_t就是一些hal层需要提供给jni调用的函数指针。&lt;/p&gt;
&lt;p&gt;再回到open函数中，现在我们就能看懂这个open函数所做的工作了，它首先注册了一个&lt;code&gt;struct lcd_reflect_device_t *dev; lcd_reflect_device_t&lt;/code&gt;变量，然后填充common，也就是hw_device_t这个结构，这里需要注意有几个成员：&lt;/p&gt;
&lt;p&gt;tag：必须指定为&lt;code&gt;HARDWARE_DEVICE_TAG&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还需要实现一个close函数，接着*device= &amp;amp;dev-&amp;gt;common;，即让jni的hw_device_t与hal中的&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;联系在一起了，由于common这个成员在&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;的最前面定义的，那么也就是&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;的地址和common的地址是相同的。只要知道common的地址就可以知道&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;的地址，这样&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;结构就可以传送到jni层使用了，只需要将common的地址强制转换一下即可。最后把hal层需要提供给jni的API实现就可以了。这样一个简单的hal层代码框架就有啦。&lt;/p&gt;
&lt;h2 id="45cc179d49cae26720730453c5546be2"&gt;调用HAL&lt;/h2&gt;
&lt;p&gt;在jni层，我们通过hw_get_module函数得到hw_module_t结构，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hw_get_module(LCD_REFLECT_HARDWARE_MODULE_ID,(hw_module_t const**)&amp;amp;module);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过指定&lt;code&gt;LCD_REFLECT_HARDWARE_MODULE_ID&lt;/code&gt;来区别module,接着还需要得到&lt;code&gt;lcd_reflect_device_t*device;&lt;/code&gt;这个结构，我们可以通过下面这个函数实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;static lcd_reflect_device_t *
get_device(hw_module_t *module, char const *name)
{
    int err;
    hw_device_t *device;

    err = module-&amp;gt;methods-&amp;gt;open(module, name, &amp;amp;device);
    if (err == 0) {
        return (lcd_reflect_device_t *)device;
    } else {
        return NULL;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数返回的是&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;结构的地址，在函数中首先定义&lt;code&gt;hw_device_t*device;&lt;/code&gt;接着将其通过&lt;code&gt;module-&amp;gt;methods-&amp;gt;open(module,name, &amp;amp;device);&lt;/code&gt;得到&lt;code&gt;hw_device_t&lt;/code&gt;这个结构的地址，接着将这个地址返回，返回前需要将地址类型强制转换一下，&lt;code&gt;(lcd_reflect_device_t*)device&lt;/code&gt;，这样就得到&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;这个结构的地址啦。原因我们在上面讲过，是因为&lt;code&gt;hw_device_t&lt;/code&gt;和&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;两个结构的首地址是相同的。&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;lcd_reflect_device_t&lt;/code&gt;我们就可以调用hal层中实现的API啦，通过这些API操作硬件。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Shao Depeng</dc:creator><pubDate>Mon, 21 May 2012 11:29:23 +0800</pubDate><guid isPermaLink="false">tag:sdphome.github.io,2012-05-21:android/android_hal_call_and_achieve.html</guid><category>android</category><category>hal</category></item></channel></rss>